diff -Naur nova-2011.3/nova/virt/disk.py nova-2011.3.new/nova/virt/disk.py
--- nova-2011.3/nova/virt/disk.py	2011-08-23 05:17:51 +0000
+++ nova-2001.3.new/nova/virt/disk.py	2011-09-09 10:03:28 +0000
@@ -5,6 +5,8 @@
 #
 # Copyright 2011, Piston Cloud Computing, Inc.
 #
+# Copyright 2011 Grid Dynamics
+#
 # All Rights Reserved.
 #
 #    Licensed under the Apache License, Version 2.0 (the "License"); you may
@@ -23,6 +25,11 @@
 
 Includes injection of SSH PGP keys into authorized_keys file.
 
+**Related Flags**
+
+injected_network_template_dir:  Template directory for injected network
+inject_ssh_key:  Enable or disable ssh key injection
+
 """
 
 import json
@@ -37,6 +44,9 @@
 from nova import log as logging
 from nova import utils
 
+from Cheetah.Template import Template
+import guestfs
+
 
 LOG = logging.getLogger('nova.compute.disk')
 FLAGS = flags.FLAGS
@@ -44,14 +54,16 @@
                      'minimum size in bytes of root partition')
 flags.DEFINE_integer('block_size', 1024 * 1024 * 256,
                      'block_size to use for dd')
-flags.DEFINE_string('injected_network_template',
+flags.DEFINE_string('injected_network_template_dir',
                     utils.abspath('virt/interfaces.template'),
                     'Template file for injected network')
-flags.DEFINE_integer('timeout_nbd', 10,
-                     'time to wait for a NBD device coming up')
-flags.DEFINE_integer('max_nbd_devices', 16,
-                     'maximum number of possible nbd devices')
+flags.DEFINE_bool('inject_ssh_key', True, 'inject ssh key')
 
+path_map = {}
+path_map['ubuntu'] = '/etc/networking/interfaces'
+path_map['rhel'] = '/etc/sysconfig/network-scripts/ifcfg-$name'
+# Note (Ivan K.): use RHEL config as default
+path_map['unknown'] = '/etc/sysconfig/network-scripts/ifcfg-$name'
 
 def extend(image, size):
     """Increase image to size"""
@@ -64,8 +76,7 @@
     utils.execute('resize2fs', image, check_exit_code=False)
 
 
-def inject_data(image, key=None, net=None, metadata=None,
-                partition=None, nbd=False, tune2fs=True):
+def inject_data(image, key=None, nets=[], metadata=None, partition=None, nbd=False):
     """Injects a ssh key and optionally net data into a disk image.
 
     it will mount the image as a fully partitioned disk and attempt to inject
@@ -74,187 +85,94 @@
     If partition is not specified it mounts the image as a single partition.
 
     """
-    device = _link_device(image, nbd)
+    g = guestfs.GuestFS()
     try:
-        if not partition is None:
-            # create partition
-            out, err = utils.execute('kpartx', '-a', device, run_as_root=True)
-            if err:
-                raise exception.Error(_('Failed to load partition: %s') % err)
-            mapped_device = '/dev/mapper/%sp%s' % (device.split('/')[-1],
-                                                   partition)
-        else:
-            mapped_device = device
-
-        try:
-            # We can only loopback mount raw images. If the device isn't there,
-            # it's normally because it's a .vmdk or a .vdi etc
-            if not os.path.exists(mapped_device):
-                raise exception.Error('Mapped device was not found (we can'
-                                      ' only inject raw disk images): %s' %
-                                      mapped_device)
-
-            if tune2fs:
-                # Configure ext2fs so that it doesn't auto-check every N boots
-                out, err = utils.execute('tune2fs', '-c', 0, '-i', 0,
-                                         mapped_device, run_as_root=True)
+        LOG.debug(_("Mounting disk..."))
+        g.add_drive(image)
+        g.launch()
+        devices = g.inspect_os()
+        device = devices[0]
+        g.mount(device,"/")
+        if key and FLAGS.inject_ssh_key:
+            LOG.debug(_("Injecting SSH key..."))
+            sshdir = "/root/.ssh"
+            path = sshdir + "/authorized_keys"
+            if not g.is_dir(sshdir):
+                g.mkdir_p(sshdir)
+                g.chmod(0700, sshdir)
+            g.write(path, key)
+            g.chmod(0600, path)
+
+        net = []
+        os_name = g.inspect_get_distro(device)
+
+        if metadata:
             tmpdir = tempfile.mkdtemp()
-            try:
-                # mount loopback to dir
-                out, err = utils.execute('mount', mapped_device, tmpdir,
-                                         run_as_root=True)
-                if err:
-                    raise exception.Error(_('Failed to mount filesystem: %s')
-                                          % err)
-
-                try:
-                    inject_data_into_fs(tmpdir, key, net, metadata,
-                                        utils.execute)
-                finally:
-                    # unmount device
-                    utils.execute('umount', mapped_device, run_as_root=True)
-            finally:
-                # remove temporary directory
-                utils.execute('rmdir', tmpdir)
-        finally:
-            if not partition is None:
-                # remove partitions
-                utils.execute('kpartx', '-d', device, run_as_root=True)
-    finally:
-        _unlink_device(device, nbd)
-
-
-def setup_container(image, container_dir=None, nbd=False):
-    """Setup the LXC container.
-
-    It will mount the loopback image to the container directory in order
-    to create the root filesystem for the container.
-
-    LXC does not support qcow2 images yet.
-    """
-    try:
-        device = _link_device(image, nbd)
-        utils.execute('mount', device, container_dir, run_as_root=True)
-    except Exception, exn:
-        LOG.exception(_('Failed to mount filesystem: %s'), exn)
-        _unlink_device(device, nbd)
-
-
-def destroy_container(target, instance, nbd=False):
-    """Destroy the container once it terminates.
-
-    It will umount the container that is mounted, try to find the loopback
-    device associated with the container and delete it.
-
-    LXC does not support qcow2 images yet.
-    """
-    try:
-        container_dir = '%s/rootfs' % target
-        utils.execute('umount', container_dir, run_as_root=True)
-    finally:
-        out, err = utils.execute('losetup', '-a', run_as_root=True)
-        for loop in out.splitlines():
-            if instance['name'] in loop:
-                device = loop.split(loop, ':')
-                _unlink_device(device, nbd)
-
-
-def _link_device(image, nbd):
-    """Link image to device using loopback or nbd"""
-
-    if nbd:
-        device = _allocate_device()
-        utils.execute('qemu-nbd', '-c', device, image, run_as_root=True)
-        # NOTE(vish): this forks into another process, so give it a chance
-        #             to set up before continuuing
-        for i in xrange(FLAGS.timeout_nbd):
-            if os.path.exists("/sys/block/%s/pid" % os.path.basename(device)):
-                return device
-            time.sleep(1)
-        raise exception.Error(_('nbd device %s did not show up') % device)
-    else:
-        out, err = utils.execute('losetup', '--find', '--show', image,
-                                 run_as_root=True)
-        if err:
-            raise exception.Error(_('Could not attach image to loopback: %s')
-                                  % err)
-        return out.strip()
-
-
-def _unlink_device(device, nbd):
-    """Unlink image from device using loopback or nbd"""
-    if nbd:
-        utils.execute('qemu-nbd', '-d', device, run_as_root=True)
-        _free_device(device)
-    else:
-        utils.execute('losetup', '--detach', device, run_as_root=True)
-
-
-_DEVICES = ['/dev/nbd%s' % i for i in xrange(FLAGS.max_nbd_devices)]
-
-
-def _allocate_device():
-    # NOTE(vish): This assumes no other processes are allocating nbd devices.
-    #             It may race cause a race condition if multiple
-    #             workers are running on a given machine.
-
-    while True:
-        if not _DEVICES:
-            raise exception.Error(_('No free nbd devices'))
-        device = _DEVICES.pop()
-        if not os.path.exists("/sys/block/%s/pid" % os.path.basename(device)):
-            break
-    return device
-
-
-def _free_device(device):
-    _DEVICES.append(device)
-
-
-def inject_data_into_fs(fs, key, net, metadata, execute):
-    """Injects data into a filesystem already mounted by the caller.
-    Virt connections can call this directly if they mount their fs
-    in a different way to inject_data
-    """
-    if key:
-        _inject_key_into_fs(key, fs, execute=execute)
-    if net:
-        _inject_net_into_fs(net, fs, execute=execute)
-    if metadata:
-        _inject_metadata_into_fs(metadata, fs, execute=execute)
-
-
-def _inject_metadata_into_fs(metadata, fs, execute=None):
-    metadata_path = os.path.join(fs, "meta.js")
-    metadata = dict([(m.key, m.value) for m in metadata])
-
-    utils.execute('sudo', 'tee', metadata_path,
-                  process_input=json.dumps(metadata))
-
-
-def _inject_key_into_fs(key, fs, execute=None):
-    """Add the given public ssh key to root's authorized_keys.
-
-    key is an ssh key string.
-    fs is the path to the base of the filesystem into which to inject the key.
-    """
-    sshdir = os.path.join(fs, 'root', '.ssh')
-    utils.execute('mkdir', '-p', sshdir, run_as_root=True)
-    utils.execute('chown', 'root', sshdir, run_as_root=True)
-    utils.execute('chmod', '700', sshdir, run_as_root=True)
-    keyfile = os.path.join(sshdir, 'authorized_keys')
-    utils.execute('tee', '-a', keyfile,
-                  process_input='\n' + key.strip() + '\n', run_as_root=True)
-
-
-def _inject_net_into_fs(net, fs, execute=None):
-    """Inject /etc/network/interfaces into the filesystem rooted at fs.
-
-    net is the contents of /etc/network/interfaces.
-    """
-    netdir = os.path.join(os.path.join(fs, 'etc'), 'network')
-    utils.execute('mkdir', '-p', netdir, run_as_root=True)
-    utils.execute('chown', 'root:root', netdir, run_as_root=True)
-    utils.execute('chmod', 755, netdir, run_as_root=True)
-    netfile = os.path.join(netdir, 'interfaces')
-    utils.execute('tee', netfile, process_input=net, run_as_root=True)
+            metadata_path = os.path.join(tmpdir, "meta.js")
+            metadata = dict([(m.key, m.value) for m in metadata])
+            g.write(metadata_path, metadata)
+
+        if os_name == "ubuntu":
+            ifc_template = open(os.path.join(FLAGS.injected_network_template_dir, "interfaces.ubuntu.template")).read()
+            net = [
+                {'name': x['name'],
+                 'data':
+                     str
+                         (Template(ifc_template,
+                                  searchList=[x, {'use_ipv6': FLAGS.use_ipv6}]))}
+                    for x in nets]
+            if len(net):
+                net = str(Template(ifc_template,
+                               searchList=[{'interfaces': nets,
+                                            'use_ipv6': FLAGS.use_ipv6}]))
+                LOG.debug(_("Injecting network for interface %(name)s..."
+                                                                        % net))
+                path = get_network_interface_config_path(g, device, net)
+                if path:
+                    g.write(path, net['data'])
+                else:
+                    raise Exception
+        if os_name == "rhel":
+            ifc_template = open(os.path.join(FLAGS.injected_network_template_dir, "interfaces.rhel.template")).read()
+            net = [
+                {'name': x['name'],
+                 'data':
+                      str
+                       (Template(ifc_template,
+                             searchList=[x, {'use_ipv6': FLAGS.use_ipv6}]))}
+                     for x in nets]
+            if len(net):
+                for n in net:
+                     LOG.debug(_("Injecting network for interface %(name)s..."
+                                                                         % n))
+                     path = get_network_interface_config_path(g, device, n)
+                     g.write(path, n['data'])
+    except Exception as e:
+        LOG.exception(e)
+        raise
+    finally:
+        LOG.debug(_("Deleting guestfs object..."))
+        g.umount_all()
+        del(g)
+
+
+def get_network_interface_config_path(gfs, device, net):
+    """ Returns path to the file with network interfaces configuration
+
+    It will return linux distributive specific path for
+    the network interface configuration file.
+
+    Returns path to RHEL configuration file by default
+    """
+
+    distro = gfs.inspect_get_distro(device)
+    path = str(Template(path_map[distro], searchList=[{'name': net['name']}]))
+    if not gfs.is_file(path):
+        for template in path_map.itervalues():
+            p = str(Template(template, searchList=[{'name': net['name']}]))
+            if gfs.is_file(p):
+                path = p
+                break
+    if path != 'unknown':
+        return path
+    raise IOError('Can not get path to network interfaces config.')
\ No newline at end of file

diff -Naur nova-2011.3/nova/virt/libvirt/connection.py nova-2011.3.new/nova/virt/libvirt/connection.py
--- nova-2011.3/nova/virt/libvirt/connection.py	2011-08-26 01:38:35 +0000
+++ nova-2011.3.new/nova/virt/libvirt/connection.py	2011-09-09 10:03:37 +0000
@@ -921,7 +921,6 @@
         net = None
 
         nets = []
-        ifc_template = open(FLAGS.injected_network_template).read()
         ifc_num = -1
         have_injected_networks = False
         admin_context = nova_context.get_admin_context()
@@ -952,13 +951,8 @@
                    'netmask_v6': netmask_v6}
             nets.append(net_info)
 
-        if have_injected_networks:
-            net = str(Template(ifc_template,
-                               searchList=[{'interfaces': nets,
-                                            'use_ipv6': FLAGS.use_ipv6}]))
-
         metadata = inst.get('metadata')
-        if any((key, net, metadata)):
+        if any((key, len(nets), metadata)):
             inst_name = inst['name']
 
             if config_drive:  # Should be True or None by now.
@@ -976,10 +970,9 @@
                                '%(injection)s into image %(img_id)s'
                                % locals()))
             try:
-                disk.inject_data(injection_path, key, net, metadata,
+                disk.inject_data(injection_path, key, nets, metadata,
                                  partition=target_partition,
-                                 nbd=FLAGS.use_cow_images,
-                                 tune2fs=tune2fs)
+                                 nbd=FLAGS.use_cow_imagess)
 
                 if FLAGS.libvirt_type == 'lxc':
                     disk.setup_container(basepath('disk'),

